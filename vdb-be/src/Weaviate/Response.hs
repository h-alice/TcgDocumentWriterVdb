{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE InstanceSigs      #-}
{-# LANGUAGE StrictData        #-} -- Consider adding StrictData for fields by default

-- |
-- Module      : Weaviate.Response
-- Description : Data types and JSON parsing for Weaviate GraphQL 'Get' responses.
-- Copyright   : (c) 2025 Wayne "h-alice" Hong
-- License     : AGPL-3.0
-- Maintainer  : admin@halice.art
-- Stability   : experimental
-- Portability : POSIX
--
-- This module provides Haskell data types that mirror the structure of JSON
-- responses from Weaviate's GraphQL API, specifically for @Get@ queries.
-- It defines 'FromJSON' instances using "Data.Aeson" for automatic decoding.
--
-- The parser handles the typical nested structure:
--
-- @
-- {
--   "data": {
--     "Get": {
--       "YourCollectionName": [ -- Handled dynamically
--         {
--           "_additional": { "id": "...", "score": "...", "explainScore": "..." },
--           "content": "...",
--           "summary": "...",
--           "orig": [{ "content": "..." }] -- New field
--           -- Potentially other fields defined in your Weaviate schema
--         },
--         -- ... more results
--       ]
--     }
--   }
-- }
-- @
--
-- Usage typically involves decoding a 'ByteString' response body:
--
-- > import Data.Aeson (eitherDecode)
-- > import qualified Data.ByteString.Lazy as BL
-- >
-- > decodeResponse :: BL.ByteString -> Either String WeaviateResponse
-- > decodeResponse = eitherDecode
--
module Weaviate.Response
  ( -- * Response Types
    WeaviateResponse(..)
  , GetResponseData(..)
  , GetDocument(..)
  , QueryResult(..)
  , AdditionalInfo(..)
  , OriginalDocument(..) -- --- ADDED: Export new type
    -- * Decoding Note
    -- | Use 'Data.Aeson.eitherDecode' or 'Data.Aeson.decode' from the @aeson@
    --   library to parse a JSON 'BL.ByteString' into a 'WeaviateResponse'.
    --   The 'FromJSON' instances defined here handle the specific structure.
  ) where

import Data.Aeson     (FromJSON (parseJSON), Value, withObject, (.:))
import GHC.Generics   (Generic)
import qualified Data.Text               as T (Text, unpack)
import qualified Data.Aeson.Types        as AesonTypes (Parser)
import qualified Data.Aeson.KeyMap       as KM

-- | Represents the @_additional@ metadata object within a Weaviate result.
--   Contains information generated by Weaviate during the query, such as ID and score.
--   See Weaviate documentation for details on these fields.
data AdditionalInfo = AdditionalInfo
    { addExplainScore :: !T.Text -- ^ Explanation of the score (vector search). Corresponds to JSON key @\"explainScore\"@.
    , addId           :: !T.Text -- ^ The unique identifier (UUID) of the object. Corresponds to JSON key @\"id\"@.
    , addScore        :: !Double -- ^ The calculated relevance score. Corresponds to JSON key @\"score\"@.
                                 --   /Note:/ Parsed from a JSON String, fails if not a valid floating-point representation.
    } deriving (Show, Eq, Generic)

-- | Parses the @_additional@ object from JSON.
--   Handles the conversion of the @score@ field from Text to Double.
instance FromJSON AdditionalInfo where
    parseJSON :: Value -> AesonTypes.Parser AdditionalInfo
    parseJSON = withObject "AdditionalInfo" $ \v -> do
        explainScore <- v .: "explainScore"
        idVal        <- v .: "id"
        scoreText    <- v .: "score"
        -- Attempt to parse score Text to Double, fail explicitly on error
        case reads (T.unpack scoreText) of
            [(num, "")] -> -- Successfully read one Double, consumed whole string
                return AdditionalInfo { addExplainScore = explainScore
                                      , addId = idVal
                                      , addScore = num
                                      }
            _ -> fail $ "Could not parse 'score' field value as Double: " ++ T.unpack scoreText


-- --- ADDED: Data type for the objects within the 'orig' array
-- | Represents an original document snippet, typically containing its content.
data OriginalDocument = OriginalDocument
    { odContent :: !T.Text -- ^ The content of the original document part. Maps to JSON key @\"content\"@.
    } deriving (Show, Eq, Generic)

-- --- ADDED: FromJSON instance for OriginalDocument
instance FromJSON OriginalDocument where
    parseJSON :: Value -> AesonTypes.Parser OriginalDocument
    parseJSON = withObject "OriginalDocument" $ \v ->
        OriginalDocument <$> v .: "content"


-- | Represents a single document result within the results array.
--   Includes standard fields like @content@ and @summary@, plus Weaviate metadata.
data QueryResult = QueryResult
    { qrAdditional :: !AdditionalInfo    -- ^ Metadata like ID and score ('AdditionalInfo'). Maps to JSON key @\"_additional\"@.
    , qrContent    :: !T.Text            -- ^ The main content field. Maps to JSON key @\"content\"@.
    , qrSummary    :: !T.Text            -- ^ The summary field. Maps to JSON key @\"summary\"@.
    , qrOrig       :: ![OriginalDocument] -- --- MODIFIED: Added 'orig' field. Maps to JSON key @\"orig\"@.
    -- Add other fields from your schema here if needed
    } deriving (Show, Eq, Generic)

-- | Parses a single result object from JSON.
instance FromJSON QueryResult where
    parseJSON :: Value -> AesonTypes.Parser QueryResult
    parseJSON = withObject "QueryResult" $ \v ->
        QueryResult <$> v .: "_additional"
                    <*> v .: "content"
                    <*> v .: "summary"
                    <*> v .: "orig" -- --- MODIFIED: Parse the new 'orig' field
        -- If adding optional fields:
        -- <*> v .:? "optionalField" -- Needs Maybe type in QueryResult


-- | Represents the value associated with the dynamically named collection
--   field inside the @Get@ object (e.g., @\"DocumentDoc\"@).
--   It primarily acts as a wrapper for the list of 'QueryResult' objects.
--
--   /Important:/ The 'FromJSON' instance expects the JSON object being parsed
--   to contain __exactly one__ field. The name of this field is ignored,
--   but its value must be an array of objects parseable as 'QueryResult'.
--   Parsing fails if the object is empty or contains multiple fields.
newtype GetDocument = GetDocument
    { gdResults :: [QueryResult] -- ^ The list of results ('QueryResult').
    } deriving (Show, Eq, Generic)

-- | Custom 'FromJSON' instance for 'GetDocument'.
--   Parses an object containing exactly one field, where the field's value
--   is the array of results. Ignores the field's name.
instance FromJSON GetDocument where
    parseJSON :: Value -> AesonTypes.Parser GetDocument
    parseJSON = withObject "GetDocument Container" $ \v -> do
        case KM.toList v of
            [] -> fail "No collection field found inside the 'Get' object. Expected one field like 'CollectionName': [...]"
            [(_, resultsValue)] -> -- Extract the value of the single field
                GetDocument <$> parseJSON resultsValue -- Parse the value as [QueryResult]
            _ -> fail $ "Multiple fields found inside the 'Get' object: " ++ show (KM.keys v) ++ ". Expected exactly one collection field."


-- | Represents the object nested under the @\"data\"@ key, containing the @\"Get\"@ object.
newtype GetResponseData = GetResponseData
    { grdGet :: GetDocument -- ^ The parsed content of the @\"Get\"@ object ('GetDocument'). Maps to JSON key @\"Get\"@.
    } deriving (Show, Eq, Generic)

-- | Parses the @data@ object's content, specifically extracting the @\"Get\"@ field.
instance FromJSON GetResponseData where
    parseJSON :: Value -> AesonTypes.Parser GetResponseData
    parseJSON = withObject "GetResponseData" $ \v ->
        GetResponseData <$> v .: "Get" -- Uses GetDocument's FromJSON instance


-- | Represents the top-level structure of a Weaviate GraphQL @Get@ response.
newtype WeaviateResponse = WeaviateResponse
    { wrData :: GetResponseData -- ^ The main data payload ('GetResponseData'). Maps to the top-level JSON key @\"data\"@.
    } deriving (Show, Eq, Generic)

-- | Parses the entire Weaviate response, starting from the top-level @\"data\"@ key.
instance FromJSON WeaviateResponse where
    parseJSON :: Value -> AesonTypes.Parser WeaviateResponse
    parseJSON = withObject "WeaviateResponse" $ \v ->
        WeaviateResponse <$> v .: "data" -- Uses GetResponseData's FromJSON instance